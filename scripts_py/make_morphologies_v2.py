import numpy as np
from neurom import load_morphology
from neurom.core import Morphology
from neurom import * 
import neurom as nm
import matplotlib.pyplot as plt
import seaborn as sns
from neurom.core.types import tree_type_checker
import networkx as nx
from tqdm import tqdm
import argparse
import pandas as pd
from neurom import iter_sections
from neurom.features import section
import os
from neurom import morphmath as mm
from neurom.view import plot_morph, plot_morph3d, plot_dendrogram
import os
import numpy as np
import pandas as pd
from neurom import load_morphology, iter_sections
from neurom.core.dataformat import COLS
from neurom import morphmath as mm
import numpy as np
from neurom import load_morphology
from neurom.core import Morphology
from neurom import iter_sections
from neurom.core import Section

def save_swc_custom(morphology, output_path):
    """
    Salva una morfologia neuronale in formato SWC.
    :param morphology: Oggetto Morphology di neurom.
    :param output_path: Percorso di output per il file SWC.
    """
    with open(output_path, 'w') as swc_file:
        swc_file.write("# SWC file generated by SWCHandler\n")
        node_id = 1
        for neurite in morphology.neurites:
            for point in neurite.points:
                # Scrive ogni punto in formato SWC: ID, tipo, X, Y, Z, raggio, parent
                parent_id = point.parent.id if point.parent else -1
                swc_file.write(
                    f"{node_id} 3 {point[0]} {point[1]} {point[2]} {point.radius} {parent_id}\n"
                )
                node_id += 1
    print(f"File SWC salvato in: {output_path}")




def adaptSWC(cell, file_path):
    cell_labels = {
        'PurkinjeCell': ['soma', 'axon_basal_AIS', 'axon_basal_AIS_K', 'axon_apical_myelin', 'axon_apical_nodes', 
                         'dend_basal', 'dend_apical_pf_sc_targets', 'dend_apical_aa_sc_targets'],
        'GolgiCell': ['soma', 'axon_basal', 'dend_basal', 'dend_apical', 'axon_apical'],
        'BasketCell': ['soma', 'axon_distal', 'dend', 'axon_initial'],
        'GranuleCell': ['soma', 'dend', 'axon_hillock', 'axon_initial', 'axon_ascending_fb', 'axon_parallel_fb'],
        'StellateCell': ['soma', 'axon_distal', 'dend_prox', 'dend_distal', 'axon_initial']
    }
    if cell not in cell_labels:
        raise ValueError(f"Tipo di cellula '{cell}' non supportato.")
    labels = cell_labels[cell]
    swc = np.loadtxt(file_path, comments='#')
    swc_df = pd.DataFrame(data=swc, columns=['i', 'id_labels', 'x', 'y', 'z', 'r', 'j'])
    unique_labels = np.unique(swc_df['id_labels'])
    if len(unique_labels) != len(labels):
        raise ValueError("Numero di etichette non corrisponde.")
    mapping = {num: name for num, name in zip(unique_labels, labels)}
    swc_df['txt_labels'] = swc_df['id_labels'].map(mapping)
    
    def map_label(label):
        if 'soma' in label:
            return 1
        elif 'axon' in label:
            return 2
        elif 'dend' in label:
            return 3
        return 0
    
    swc_df['id_labels'] = swc_df['txt_labels'].map(map_label)
    output_path = file_path.replace('.swc', '_adapted.swc')
    with open(output_path, 'w') as f:
        #f.write("# ID TYPE X Y Z RADIUS PARENT\n")
        for _, row in swc_df.iterrows():
            f.write(f"{int(row['i'])} {int(row['id_labels'])} {row['x']:.3f} {row['y']:.3f} {row['z']:.3f} {row['r']:.3f} {int(row['j'])}\n")
    
    # Rimuovi la colonna 'txt_labels' prima di salvare
    swc_k = swc_k.drop(columns=['txt_labels'])
    swc_k[['i', 'id_labels', 'j']] = swc_k[['i', 'id_labels', 'j']].astype(int)
    swc_k_output_path = f'./morphologies/{cell}/{cell}_{k:.3f}_ext.swc'
    swc_k.to_csv(swc_k_output_path, sep=' ', header=False, index=False)
    
    return output_path

def save_swc_custom(morphology, output_path):
    """
    Salva una morfologia neuronale in formato SWC senza rimappare gli ID.
    :param morphology: Oggetto Morphology di neurom.
    :param output_path: Percorso di output per il file SWC.
    """
    with open(output_path, 'w') as swc_file:
        swc_file.write("# SWC file generated by SWCHandler (original IDs preserved)\n")
        for point in morphology.neurites.points:
            parent_id = point.parent.id if point.parent else -1  # Mantiene il parent originale
            swc_file.write(f"{point.id} {point.type} {point[0]} {point[1]} {point[2]} {point.radius} {parent_id}\n")
    print(f"File SWC originale salvato in: {output_path}")

def adaptSWC_v2(cell, file_path, k):
    """
    Modifica il file SWC rimappando gli ID e genera due versioni:
    - `_adapted.swc`: con gli ID rimappati.
    - `_ext.swc`: senza rimappare gli ID.

    :param cell: Nome della cellula (es. 'PurkinjeCell').
    :param file_path: Percorso del file SWC originale.
    :param k: Valore di scalatura da includere nel nome del file di output.
    :return: Percorso dei file generati.
    """

    # Mappatura delle etichette per ciascun tipo di cellula
    cell_labels = {
        'PurkinjeCell': ['soma', 'axon_basal_AIS', 'axon_basal_AIS_K', 'axon_apical_myelin', 'axon_apical_nodes', 
                         'dend_basal', 'dend_apical_pf_sc_targets', 'dend_apical_aa_sc_targets'],
        'GolgiCell': ['soma', 'axon_basal', 'dend_basal', 'dend_apical', 'axon_apical'],
        'BasketCell': ['soma', 'axon_distal', 'dend', 'axon_initial'],
        'GranuleCell': ['soma', 'dend', 'axon_hillock', 'axon_initial', 'axon_ascending_fb', 'axon_parallel_fb'],
        'StellateCell': ['soma', 'axon_distal', 'dend_prox', 'dend_distal', 'axon_initial']
    }

    if cell not in cell_labels:
        raise ValueError(f"Tipo di cellula '{cell}' non supportato.")

    labels = cell_labels[cell]

    # Carica il file SWC in un DataFrame
    swc = np.loadtxt(file_path, comments='#')
    swc_df = pd.DataFrame(data=swc, columns=['i', 'id_labels', 'x', 'y', 'z', 'r', 'j'])

    # Mappatura etichette per il remapping degli ID
    unique_labels = np.unique(swc_df['id_labels'])
    if len(unique_labels) != len(labels):
        raise ValueError("Il numero di etichette nel file SWC non corrisponde a quello atteso.")

    mapping = {num: name for num, name in zip(unique_labels, labels)}
    swc_df['txt_labels'] = swc_df['id_labels'].map(mapping)

    # Funzione di mappatura degli ID rimappati
    def map_label(label):
        if 'soma' in label:
            return 1
        elif 'axon' in label:
            return 2
        elif 'dend' in label:
            return 3
        return 0
    
    # Creazione del file **con rimappatura degli ID**
    swc_adapted = swc_df.copy()
    swc_adapted['id_labels'] = swc_adapted['txt_labels'].map(map_label)

    adapted_output_path = f'./morphologies/{cell}/{cell}_{k:.3f}_adapted.swc'
    with open(adapted_output_path, 'w') as f:
        for _, row in swc_adapted.iterrows():
            f.write(f"{int(row['i'])} {int(row['id_labels'])} {row['x']:.3f} {row['y']:.3f} {row['z']:.3f} {row['r']:.3f} {int(row['j'])}\n")

    print(f"File SWC adattato salvato in: {adapted_output_path}")

    # Creazione del file **senza rimappatura degli ID**
    #swc_ext = swc_df.drop(columns=['txt_labels'])  # Mantieni ID originali
    #swc_ext[['i', 'id_labels', 'j']] = swc_ext[['i', 'id_labels', 'j']].astype(int)
    #ext_output_path = f'./morphologies/{cell}/{cell}_{k:.3f}_ext.swc'
    #swc_ext.to_csv(ext_output_path, sep=' ', header=False, index=False)
    #[print(f"File SWC originale (senza rimappatura) salvato in: {ext_output_path}")

    return adapted_output_path


def count_branch_tips(morphology):
    """
    Counts the number of branch tips in a morphology.
    
    :param morphology: Morphology object loaded using Neurom.
    :return: Total number of branch tips.
    """
    return sum(
        1 for _ in iter_sections(morphology, iterator_type=Section.ibifurcation_point)
    )
    


def branch_tip_orders(morphology):
    """
    Computes the branch tip orders for all branch tips in a morphology.
    
    :param morphology: Morphology object loaded using Neurom.
    :return: List of branch tip orders.
    """
    return [
        section.branch_order(sec)
        for sec in iter_sections(morphology)
        if len(sec.children) == 0  # Only include terminal sections (branch tips)
    ]


def extract_morphometric_data_v2(morphology, do_plot=True, do_save=True):
    total_length = sum(mm.section_length(sec.points) for sec in iter_sections(morphology))
    num_sections = sum(1 for _ in iter_sections(morphology))
    branch_tips = count_branch_tips(morphology)
    tip_orders = branch_tip_orders(morphology)
    mean_radius = np.mean([p[COLS.R] for sec in iter_sections(morphology) for p in sec.points])
    total_volume = sum(mm.segment_volume(seg) for seg in morphology.segments)
    DCI = (sum(tip_orders) + branch_tips) * total_length

    # Handle soma radius
    soma_radius = (
        np.mean([p[COLS.R] for p in morphology.soma.iter()])
        if morphology.soma else np.nan
    )
    
    axon_radius = np.mean(
        [p[COLS.R] for sec in iter_sections(morphology, neurite_filter=tree_type_checker(AXON)) for p in sec.points]
    ) if any(tree_type_checker(AXON)(sec) for sec in iter_sections(morphology)) else 0

    dend_radius = np.mean(
        [p[COLS.R] for sec in iter_sections(morphology, neurite_filter=tree_type_checker(BASAL_DENDRITE)) for p in sec.points] +
        [p[COLS.R] for sec in iter_sections(morphology, neurite_filter=tree_type_checker(APICAL_DENDRITE)) for p in sec.points]
    ) if any(tree_type_checker(BASAL_DENDRITE)(sec) or tree_type_checker(APICAL_DENDRITE)(sec) for sec in iter_sections(morphology)) else 0

    data = {
        "cell_name": morphology.name.split('_')[0],
        "total_length": total_length,
        "num_sections": num_sections,
        "num_branch_tips": branch_tips,
        "num_tip_orders": len(tip_orders),
        "mean_radius": mean_radius,
        "mean_soma_radius": soma_radius,
        "mean_axon_radius": axon_radius,
        "mean_dend_radius": dend_radius,
        "total_volume": total_volume,
        "DCI": DCI,
    }


    return pd.DataFrame([data])



def save_plots(morphology, save_path, base_name, do_show=False):
    """
    Generates and saves plots for the morphology.
    
    :param morphology: Morphology object loaded with Neurom.
    :param save_path: Directory where plots will be saved.
    :param base_name: Base name for saving plot files.
    """
    os.makedirs(save_path, exist_ok=True)

    # 2D morphology plot
    plot_morph(morphology, realistic_diameters=True)
    plt.savefig(os.path.join(save_path, f"{base_name}_2D_plot.png"))
    if do_show==False: plt.close()
    # 3D morphology plot
    #plot_morph3d(morphology)
    #plt.savefig(os.path.join(save_path, f"{base_name}_3D_plot.png"))
    #if do_show==False: plt.close()
    # Dendrogram
    #plot_dendrogram(morphology)
    #plt.savefig(os.path.join(save_path, f"{base_name}_dendrogram.png"))
    #if do_show==False: plt.close()

def scale_radius_morphology(swc_df, scale_factor):
    """
    Scales the radius of all nodes in the morphology DataFrame.
    
    :param swc_df: DataFrame representing the SWC file.
    :param scale_factor: Scaling factor for the radius.
    :return: Updated DataFrame with scaled radii.
    """
    swc_df['r'] *= scale_factor
    return swc_df

def scale_radius_morphology_v2(swc_df, scale_factor):
    """
    Scales the radius of nodes in the morphology DataFrame conditionally:
    - Soma (id_labels == 1) and Dendrites (id_labels == 3): radius *= scale_factor
    - Axon (id_labels == 2): radius *= (1 + scale_factor)
    
    :param swc_df: DataFrame representing the SWC file.
    :param scale_factor: Scaling factor for the radius.
    :return: Updated DataFrame with scaled radii.
    """
    # Scale soma and dendrites
    swc_df.loc[swc_df['id_labels'].isin([1, 2, 3]), 'r'] *= scale_factor

    # Scale axon
    #swc_df.loc[swc_df['id_labels'] == 2, 'r'] *= (1 + abs((1-scale_factor)))
    
    return swc_df

def prune_morphology(swc_df, scale_factor):
    geodetic_distances = {node: np.random.random() for node in swc_df['i']}  # Example distances
    soma_label = 1
    dists = np.array(list(geodetic_distances.values()))
    distance_threshold = np.quantile(dists, scale_factor)

    nodes_to_remove = [
        node for node, dist in geodetic_distances.items()
        if swc_df.loc[swc_df['i'] == node, 'id_labels'].iloc[0] != soma_label and dist >= distance_threshold
    ]

    pruned_df = swc_df[~swc_df['i'].isin(nodes_to_remove)].copy()

    # Update parent-child relationships
    id_mapping = {old_id: new_id for new_id, old_id in enumerate(pruned_df['i'], start=1)}
    pruned_df['i'] = pruned_df['i'].map(id_mapping)
    pruned_df['j'] = pruned_df['j'].map(id_mapping).fillna(-1).astype(int)

    # Ensure no invalid parent IDs remain
    valid_ids = set(pruned_df['i'])
    pruned_df['j'] = pruned_df['j'].apply(lambda pid: pid if pid in valid_ids or pid == -1 else -1)


    return pruned_df


def prune_morphology_v2(swc_df, scale_factor):
    """
    Prunes the morphology by removing nodes based on geodetic distances
    and updates parent-child relationships.

    :param swc_df: DataFrame representing the SWC file.
    :param scale_factor: Pruning threshold as a quantile of geodetic distances.
    :return: Pruned DataFrame with valid parent-child relationships.
    """
    # Calculate soma center
    soma_df = swc_df[swc_df['id_labels'] == 1]
    soma_center = soma_df[['x', 'y', 'z']].mean().values

    # Create graph of the morphology
    graph = nx.Graph()
    for _, row in swc_df.iterrows():
        if row['j'] > 0:  # Only consider valid parent-child connections
            graph.add_edge(row['i'], row['j'], 
                           weight=np.linalg.norm(
                               swc_df.loc[swc_df['i'] == row['i'], ['x', 'y', 'z']].values[0] - 
                               swc_df.loc[swc_df['i'] == row['j'], ['x', 'y', 'z']].values[0]
                           ))

    # Calculate geodetic distances from the soma
    soma_index = soma_df['i'].iloc[0]
    geodetic_distances = nx.single_source_dijkstra_path_length(graph, soma_index)

    # Determine distance threshold
    dists = np.array(list(geodetic_distances.values()))
    distance_threshold = np.quantile(dists, scale_factor)

    # Identify nodes to prune
    nodes_to_remove = [
        node for node, dist in geodetic_distances.items()
        if swc_df.loc[swc_df['i'] == node, 'id_labels'].iloc[0] != 1 and dist >= distance_threshold
    ]

    # Remove nodes from the DataFrame
    pruned_df = swc_df[~swc_df['i'].isin(nodes_to_remove)].copy()


    return pruned_df

def shrink_morphology(swc_df, shrink_factor):
    """
    Shrinks the spatial coordinates and radii of the morphology.

    :param swc_df: Pandas DataFrame containing the SWC morphology data.
    :param shrink_factor: Scaling factor to shrink the coordinates and radii.
    :return: Updated DataFrame with shrunk morphology.
    """
    swc_df[['x', 'y', 'z']] *= shrink_factor
    
    return swc_df

def save_plots(input_file, morphology, save_path, base_name, do_show=False):
    """
    Generates and saves plots for the morphology with subfolders for each type of plot.

    :param input_file: Path to the original SWC file.
    :param morphology: Morphology object loaded with Neurom.
    :param save_path: Directory where plots will be saved.
    :param base_name: Base name for saving plot files.
    :param do_show: Boolean to indicate whether to display the plots or close them after saving.
    """
    import matplotlib.pyplot as plt
    from neurom.view import plot_morph, plot_morph3d, plot_dendrogram
    import pandas as pd
    import os

    # Load the original SWC file into a DataFrame
    swc_df = pd.read_csv(
        input_file,
        sep=" ",
        header=None,
        names=["i", "id_labels", "x", "y", "z", "r", "j"],
        comment="#"
    )

    # Compute bounding box limits from the original morphology
    x_min, x_max = swc_df["x"].min(), swc_df["x"].max()
    y_min, y_max = swc_df["y"].min(), swc_df["y"].max()
    z_min, z_max = swc_df["z"].min(), swc_df["z"].max()

    # Add a buffer around the bounding box for better visualization
    buffer = 0.1 * max(x_max - x_min, y_max - y_min, z_max - z_min)
    xlim = (x_min - buffer, x_max + buffer)
    ylim = (y_min - buffer, y_max + buffer)
    zlim = (z_min - buffer, z_max + buffer)

    # Ensure the save directory exists
    os.makedirs(save_path, exist_ok=True)

    # Create subfolders for different plots
    subfolders = {
        "2D_plot": os.path.join(save_path, "2D_plot"),
        "3D_plot": os.path.join(save_path, "3D_plot"),
        "dendrogram": os.path.join(save_path, "dendrogram"),
    }

    for folder in subfolders.values():
        os.makedirs(folder, exist_ok=True)

    # 2D morphology plot with fixed axes
    fig, ax = plt.subplots(figsize=(8, 8))
    plot_morph(morphology, realistic_diameters=True, ax=ax)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_title(f"{base_name} - 2D Morphology Plot")
    ax.set_xlabel("X (µm)")
    ax.set_ylabel("Y (µm)")
    plt.savefig(os.path.join(subfolders["2D_plot"], f"{base_name}_2D_plot.png"))
    if not do_show:
        plt.close()

    # 3D morphology plot with fixed axes
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection="3d")
    plot_morph3d(morphology, ax=ax)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.set_zlim(zlim)
    ax.set_title(f"{base_name} - 3D Morphology Plot")
    ax.set_xlabel("X (µm)")
    ax.set_ylabel("Y (µm)")
    ax.set_zlabel("Z (µm)")
    plt.savefig(os.path.join(subfolders["3D_plot"], f"{base_name}_3D_plot.png"))
    if not do_show:
        plt.close()

    # Dendrogram with bounding box limits
    fig, ax = plt.subplots(figsize=(8, 6))
    plot_dendrogram(morphology, ax=ax)
    ax.set_xlim(0, 500)  # Use x limits from bounding box
    ax.set_ylim(0, 750)  # Use y limits from bounding box
    ax.set_title(f"{base_name} - Dendrogram")
    ax.set_xlabel("Branch Order")
    ax.set_ylabel("Length (µm)")
    plt.savefig(os.path.join(subfolders["dendrogram"], f"{base_name}_dendrogram.png"))
    if not do_show:
        plt.close()


def make_all_morphologies(k, reserve=[0.75, 1e-3], input_dir='./morphologies', output_dir='./morphologies'):

    CELLS = ['GranuleCell', 'GolgiCell', 'PurkinjeCell', 'StellateCell', 'BasketCell']
    results_df = pd.DataFrame()

    for cell in tqdm(CELLS):
        k_gen = k
        k_shrinking = k
        k_pruning = k
        k_radius = k

        input_file = os.path.join(input_dir, f"{cell}.swc")
        base_name = os.path.splitext(os.path.basename(input_file))[0]
        os.makedirs(os.path.join(output_dir, base_name), exist_ok=True)

        # STEP 1: Carica
        swc_df = pd.read_csv(input_file, sep=' ', header=None, names=['i', 'id_labels', 'x', 'y', 'z', 'r', 'j'])

        # STEP 2: Shrink
        swc_df = shrink_morphology(swc_df, k_shrinking)

        # STEP 3: Prune
        swc_df = prune_morphology_v2(swc_df, k_pruning)

        # STEP 4: Scale radius
        swc_df = scale_radius_morphology_v2(swc_df, k_radius)

        # STEP 5: Salva ATR
        output_file = os.path.join(output_dir, base_name, f"{base_name}_{k:.3f}_atr.swc")
        swc_df.to_csv(output_file, sep=' ', header=False, index=False)

        # STEP 6: Adatta SWC
        input_file_adapted = adaptSWC_v2(base_name, output_file, k)

        # STEP 7: Carica morfologia adattata
        m = load_morphology(input_file_adapted)

        # STEP 8: Salva plots
        save_path = os.path.join(output_dir, base_name)
        save_plots(input_file, m, save_path, f"{base_name}_{k:.3f}", do_show=False)

        # STEP 9: Estrai metriche
        description = extract_morphometric_data_v2(m)
        description["k_gen"] = k_gen
        description["k_radius"] = k_radius
        description["k_pruning"] = k_pruning
        description["k_shrinking"] = k_shrinking
        description["n_soma"] = (swc_df['id_labels'] == 1).sum()
        description["n_axon"] = (swc_df['id_labels'] == 2).sum()
        description["n_dend"] = (swc_df['id_labels'] == 3).sum()

        results_df = pd.concat([results_df, description], ignore_index=True)

    results_df["Atrophy Factor (%)"] = 100 - (results_df["k_gen"] * 100)

    # Salva il DataFrame finale
    results_df.to_csv(os.path.join(output_dir, f"morphometrics_{k:.3f}.csv"), index=False)
    print(f"Saved: morphometrics_{k:.3f}.csv")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate morphologies with atrophy scaling factor k")
    parser.add_argument('--k', type=float, required=True, help="Atrophy factor k (e.g., 0.7)")
    parser.add_argument('--reserve', nargs=2, type=float, default=[0.75, 1e-3], metavar=('k0', 'sharpness'))
    args = parser.parse_args()

    make_all_morphologies(k=args.k)
